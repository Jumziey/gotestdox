[![Go Reference](https://pkg.go.dev/badge/github.com/bitfield/gotestdox.svg)](https://pkg.go.dev/github.com/bitfield/gotestdox)[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://opensource.org/licenses/MIT)
[![Go Report Card](https://goreportcard.com/badge/github.com/bitfield/gotestdox)](https://goreportcard.com/report/github.com/bitfield/gotestdox)[![CircleCI](https://circleci.com/gh/bitfield/gotestdox.svg?style=svg)](https://circleci.com/gh/bitfield/gotestdox)

```
go install github.com/bitfield/gotestdox/cmd/gotestdox@latest
```

![Writing gopher logo](img/gotestdox.png)

# `gotestdox`

`gotestdox` is a command-line tool for turning Go test names into readable sentences. For example, suppose we have some tests named like this:

```
TestRelevantIsTrueForTestPassOrFailEvents
TestRelevantIsFalseForOtherEvents
```

We can transform them into straightforward sentences that express the desired behaviour, by running `gotestdox`:

**`gotestdox`**

This will run the tests, and print:

```
 ✔ Relevant is true for test pass or fail events (0.00s)
 ✔ Relevant is false for other events (0.00s)
```

# Why

I got the idea from a blog post by Dan North, which says:

> My first “Aha!” moment occurred as I was being shown a deceptively simple utility called `agiledox`, written by my colleague, Chris Stevenson. It takes a JUnit test class and prints out the method names as plain sentences.
>
> The word “test” is stripped from both the class name and the method names, and the camel-case method name is converted into regular text. That’s all it does, but its effect is amazing.
>
> Developers discovered it could do at least some of their documentation for them, so they started to write test methods that were real sentences.\
—Dan North, [Introducing BDD](https://dannorth.net/introducing-bdd/)

# How

The original [`testdox`](https://github.com/astubbs/testdox) tool (part of `agiledox`) was very simple, as Dan describes: it just turned a camel-case JUnit test name like `testFailsForDuplicateCustomers` into a space-separated sentence like `fails for duplicate customers`.

And that's what I find neat about it: it's so simple that it hardly seems like it could be of any value, but it is. I've already used the idea to improve a lot of my test names.

There are implementations of `testdox` for various languages other than Java: for example, [PHP](https://phpunit.readthedocs.io/en/9.5/textui.html#testdox), [Python](https://pypi.org/project/pytest-testdox/), and [.NET](https://testdox.wordpress.com/). I haven't found one for Go, so here it is.

`gotestdox` reads the JSON output generated by the `go test -json` command. This is easier than trying to parse Go source code, for example, and also gives us pass/fail information for the tests. It ignores all events except pass/fail events for individual tests (including subtests).

## The rules

When it finds a relevant event, it extracts the test name and transforms it into a sentence according to the following rules:

* The leading `Test` is removed:

	`TestEverything` -> `Everything`

* Words are split on camel case and lowercased, except for the first word:

	`TestAddSumsItsInputs` -> `Add sums its inputs`

* Words are also split on underscores:

	`Test_Add_sums_its_inputs` -> `Add sums its inputs`

* All-caps words are preserved as is:

	`TestPrintGeneratesPDFFiles` -> `Print generates PDF files`

* The slashes separating test names from subtest names (in the JSON data) are removed:

	`TestPrint/does_stuff` -> `Print does stuff`

## Multi-word function names

There's an ambiguity about test names involving functions whose names contain more than one word. For example, suppose we're testing a function `HandleInput`, and we write a test like this:

```
TestHandleInputClosesInputAfterReading
```

Unless we do something, this will be rendered as:

```
 ✔ Handle input closes input after reading
```

To let us give `gotestdox` a hint about this, there's one extra transformation rule: the first underscore marks the end of the function name. So we can name our test like this:

```
TestHandleInput_ClosesInputAfterReading
```

and this becomes:

```
 ✔ HandleInput closes input after reading
```

I think this is an acceptable compromise: the `gotestdox` output is much more readable, while the extra underscore in the test name doesn't seriously interfere with its readability.

The intent is not to *perfectly* render all sensible test names as sentences, in any case, but to do *something* useful with them, primarily to encourage developers to write test names that are informative descriptions of the unit's behaviour, and thus (as a side effect) read well when formatted by `gotestdox`.

In other words, `gotestdox` is not the thing. It's the thing that gets us to the thing, the end goal being meaningful test names (I like the term _literate_ test names).

# Getting fancy

Some more advanced ways to use `gotestdox`:

## Test flags and arguments

`gotestdox`, with no arguments, will run the command `go test -json` and process its output.

Any arguments you supply will be passed on to `go test`. For example:

**`gotestdox -run ParseJSON`**

will run the command:

`go test -json -run ParseJSON`

You can supply a list of packages to test, or any other arguments or flags understood by `go test`. However, `gotestdox` only prints events about *tests* (ignoring benchmarks and examples).

## Filtering standard input

If you want to run `go test -json` yourself, for example as part of a shell pipeline, and pipe its output into `gotestdox`, you can do that too:

**`go test -json | gotestdox`**

If `gotestdox` detects that its input is not attached to a terminal, it will wait for you to pipe JSON data into it. Otherwise, it will run the tests for you and process the output.

# So what?

Why should you care, then? What's interesting about `gotestdox`, or any `testdox`-like tool, I find, is the way its output makes you think about your tests, how you name them, and what they do.

As Dan says in his blog post, turning test names into sentences is a very simple idea, but it has a powerful effect. Test names *should* be sentences.

## Test names should be sentences

I don't know about you, but I've wasted a lot of time and energy over the years trying to choose good names for tests. I didn't really have a way to evaluate whether the name I chose was good or not. Now I do!

Naming your test as a sentence actually forces you to think about how your code is supposed to *behave*, given some input or circumstances. There needs to at least be a verb.

For example, suppose we have some function `Match` that tells you whether or not a given input matches the string you're looking for:

```go
func Match(input, substring string) bool {
```

What would we name a test for this function? We might instinctively name it:

```
TestMatch
```

Pretty standard, and no doubt it does test `Match` in some way, but *what* way, actually? How is `Match` supposed to behave, according to this test? Under what circumstances? Given what input? We don't know. Suppose we're running the tests and all we see is some failure like this:

```
--- FAIL: TestMatch (0.00s)
```

That's very unhelpful. To find out what this test thinks *should* have happened, but didn't, we need to dig into the code. Ideally, the name of the test itself should tell us everything we need to know!

## Describe the behaviour you want

Of course, a good test will also give us specific information about the failure: if `want` wasn't equal to `got`, it will tell us that. But we still don't know why `want` is *supposed* to equal `got`. In other words, we're missing some critical information: what is the test actually *about*?

We need to switch from thinking about the test name as a piece of useless paperwork, and start thinking about it as documentation. As soon as we do that, it's clear that the name should be a sentence expressing what should happen when the code under test is correct:

```
Match is true for matching input
```

## Under what circumstances?

When we see that sentence, it's helpful, but it also immediately prompts us to think, "well, what about *non*-matching input?" Okay. That's another test, then:

```
TestMatchIsFalseForNonMatchingInput
```

We haven't just improved the names of our existing tests; we've actually generated new test cases. That's powerful. When we're forced to describe some particular case explicitly, it becomes obvious what *other* possibilities exist that we haven't yet tested.

## The friendly manual

And that's it! Now we have two sentences that completely describe the important behaviour of `Match`, and `gotestdox` will format them nicely for us:

```
 ✔ Match is true for matching input (0.00s)
 ✔ Match is false for non matching input (0.00s)
 ```

As you accumulate more tests over time, your `gotestdox` output will be a more and more valuable user manual for your package. And that's the right way to think about it. Good tests should focus on *user-visible* behaviour: your public API. So your tests should be named using domain terms that users understand ("A user can log in"), not computer jargon ("Initialize persistent session").

It might be interesting to show your `gotestdox` output to users, customers, or business folks, and see if it makes sense to them. If so, you're on the right lines. And it's quite likely to generate some interesting conversations ("Is that really what it does? But that's not what we asked for!")

## Subtest names should complete a sentence

`gotestdox` encourages you to create tests and subtests with descriptive names, because the results read nicely. For example, here's a snippet of one of its own tests:

```go
func TestSentence(t *testing.T) {
	t.Parallel()
	tcs := []struct {
		name, input, want string
	}{
		{
			name:  "correctly renders a well-formed test name",
			input: "TestSumCorrectlySumsInputNumbers",
			want:  "Sum correctly sums input numbers",
		},
		{
			name:  "preserves initialisms such as PDF",
			input: "TestFooGeneratesValidPDFFile",
			want:  "Foo generates valid PDF file",
		},
        ...
```

These subtests are rendered as:

```
 ✔ Sentence correctly renders a well-formed test name (0.00s)
 ✔ Sentence preserves initialisms such as PDF (0.00s)
 ...
```

In other words, it's a good idea to name each subtest so that it completes a sentence beginning with the name of the unit under test, describing the specific behaviour checked by that subtest.

If you find it weird at first writing super long test names like `TestRelevantIsFalseForOtherEvents`, don't worry. You'll get used to it quite quickly. We wouldn't want to use function names like this in our application code, certainly. But tests are different. We never *call* these functions, and users don't see them. So if it really doesn't matter what they're called, let's call them something meaningful!

When you've used `gotestdox` a little, it starts to feel perfectly natural to write your test names as descriptive sentences—which is the point, of course.

## Some examples

Here is the complete `gotestdox` rendering of its own tests (sorted for readability), in case it gives you any useful ideas:

```
 ✔ EventString formats fail events with a cross (0.00s)
 ✔ EventString formats pass events with a tick (0.00s)
 ✔ ExtractFuncName (0.00s)
 ✔ ExtractFuncName correctly extracts func name from a subtest (0.00s)
 ✔ ExtractFuncName doesn't break if the test is named just test (0.00s)
 ✔ ExtractFuncName doesn't break if the test is named just test followed by an underscore (0.00s)
 ✔ ExtractFuncName matches the first camel-case word if there are no slashes or underscores (0.00s)
 ✔ ExtractFuncName treats a single underscore as marking the end of a multi-word function name (0.00s)
 ✔ ExtractFuncName treats a single underscore before the first slash as marking the end of a multi-word function name (0.00s)
 ✔ ExtractFuncName treats multiple underscores as word breaks (0.00s)
 ✔ ExtractFuncName without an underscore before a slash treats camel case as word breaks (0.00s)
 ✔ ParseJSON correctly parses a single go test JSON output line (0.00s)
 ✔ Relevant is false for other events (0.00s)
 ✔ Relevant is true for test pass or fail events (0.00s)
 ✔ Sentence (0.00s)
 ✔ Sentence correctly renders a well-formed test name (0.00s)
 ✔ Sentence doesn't incorrectly title-case single-letter words (0.00s)
 ✔ Sentence eliminates any words containing underscores after splitting (0.00s)
 ✔ Sentence handles multiple underscores with the first marking the end of a multi-word function name (0.00s)
 ✔ Sentence inserts a word break before subtest names beginning with a lowercase letter (0.00s)
 ✔ Sentence is okay with test names not in the form of a sentence (0.00s)
 ✔ Sentence knows that just test is a valid test name (0.00s)
 ✔ Sentence preserves initialisms such as PDF (0.00s)
 ✔ Sentence preserves more initialisms (0.00s)
 ✔ Sentence renders subtest names without the slash and with underscores replaced by spaces (0.00s)
 ✔ Sentence retains apostrophised words in their original form (0.00s)
 ✔ Sentence retains hyphenated words in their original form (0.00s)
 ✔ Sentence treats a single underscore as marking the end of a multi-word function name (0.00s)
 ✔ Sentence treats a single underscore before the first slash as marking the end of a multi-word function name (0.00s)
 ✔ Sentence treats numbers as word separators (0.00s)
 ✔ Sentence treats underscores as word breaks (0.00s)
```

# Links

- [Bitfield Consulting](https://bitfieldconsulting.com/)

<small>Gopher image by [MariaLetta](https://github.com/MariaLetta/free-gophers-pack)</small>
